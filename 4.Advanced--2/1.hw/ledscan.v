//======================================================================== 
// openCologne * NLnet-sponsored open-source design ware for GateMate
//------------------------------------------------------------------------
//                   Copyright (C) 2024 Chili.CHIPS*ba
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
//
// 1. Redistributions of source code must retain the above copyright 
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright 
// notice, this list of conditions and the following disclaimer in the 
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its 
// contributors may be used to endorse or promote products derived
// from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//              https://opensource.org/license/bsd-3-clause
//------------------------------------------------------------------------
// Description: 
//========================================================================

module ledscan #(
   parameter C_bpc = 8,         // bits per RGB channel
   parameter C_bits_x = 6,      // 2^n LEDs is actual panel width
   parameter C_bits_y = 6       // 2^n LEDs is actual panel height
)(
   input clk,                             // any clock, usually 25 MHz
   input [C_bpc-1:0] r0, g0, b0,          // RGB pixel inputs 0-upper half
   input [C_bpc-1:0] r1, g1, b1,          // RGB pixel inputs 1-lower half
   
   output reg [2:0] rgb0, rgb1,           // pixel outputs, antiflickered
   output reg [C_bits_x:0] addrx,         // X counter out
   output reg [C_bits_y-2:0] addry,       // Y counter out
   output reg latch,                      // latch signal
   output reg blank                       // blank signal
);

   // Internal X/Y counters
   reg [C_bits_x:0] R_addrx;                  // one bit more to have small H-blank area
   reg [C_bits_y-2:0] R_addry;                // one bit less, iterates over half of display
   reg R_latch, R_blank;                      // latch and blank signals
   reg [C_bpc-1:0] R_bcm_counter;             // frame counter for BCM
   reg [C_bpc-1:0] S_compare_val;             // output modulation comparison value

   localparam signed [C_bits_x:0] C_2pixels_b4_1st_x_pixel = -2;
   localparam signed [C_bits_x:0] C_1pixel_b4_1st_x_pixel = -1;
   localparam [C_bits_x:0] C_last_x_pixel = (1 << C_bits_x) - 1;
   localparam [C_bits_x:0] C_1pixel_b4_last_x_pixel = (1 << C_bits_x) - 2;

   // Assign outputs
   always @(posedge clk) begin
      addrx <= R_addrx;
      addry <= R_addry;
      latch <= R_latch;
      blank <= R_blank;
   end

   // Main process that always runs
   always @(posedge clk) begin
      if (R_addrx == C_last_x_pixel) begin
         R_addrx <= C_2pixels_b4_1st_x_pixel;
      end else begin
         R_addrx <= R_addrx + 1; // x counter always runs
      end

      case (R_addrx)
         C_2pixels_b4_1st_x_pixel: begin // -2
            R_blank <= 1;
            R_addry <= R_addry + 1; // increment during blank=1
         end
         C_1pixel_b4_1st_x_pixel: begin // -1
            R_blank <= 0;
            if (R_addry == 0) begin
               R_bcm_counter <= R_bcm_counter + 1;
            end
         end
         C_1pixel_b4_last_x_pixel: begin // 62
            R_latch <= 1; // latch request 1-clock early
         end
         C_last_x_pixel: begin // 63
            R_latch <= 0; // remove latch request
         end
         default: begin
            // Do nothing
         end
      endcase
   end

   // BCM (binary code modulation) output compare against reversed bits
   always @* begin
      integer i;
      for (i = 0; i < C_bpc; i = i + 1) begin
         S_compare_val[i] = R_bcm_counter[C_bpc-1-i];
      end
   end

   // Antiflickered modulated outputs generated by arithmetic comparison against S_compare_val
   always @* begin
      rgb0[0] = (S_compare_val < r0) ? 1 : 0;
      rgb0[1] = (S_compare_val < g0) ? 1 : 0;
      rgb0[2] = (S_compare_val < b0) ? 1 : 0;
      rgb1[0] = (S_compare_val < r1) ? 1 : 0;
      rgb1[1] = (S_compare_val < g1) ? 1 : 0;
      rgb1[2] = (S_compare_val < b1) ? 1 : 0;
   end

endmodule

/*
------------------------------------------------------------------------------
Version History:
------------------------------------------------------------------------------
 2024/5/30 Ahmed ImamoviÄ‡: Initial creation
		   Adapted from: https://github.com/emard/ulx3s-misc/tree/master/examples/led64x64
*/
