from abc import abstractmethod
from amaranth import *
from amaranth.build import *
from amaranth.lib.cdc import ResetSynchronizer

__all__ = ["GateMatePlatform"]

class GateMatePlatform(TemplatedPlatform):
    """
    .. rubric:: GateMate FPGA toolchain

    Required tools:
        * ``yosys``
        * ``p_r``
        * ``openFPGALoader``

    The environment is populated by setting the ``CC_TOOL`` environment variable to point to the toolchain directory.

    Available overrides:
        * ``add_constraints``: inserts commands in CCF file.
    """

    device = property(abstractmethod(lambda: None))
    package = property(abstractmethod(lambda: None))

    toolchain = "GateMate"

    required_tools = [
        "yosys",
        "p_r",
        "openFPGALoader",
    ]

    file_templates = {
    **TemplatedPlatform.build_script_templates,
    "{{name}}.v": r"""
        /* {{autogenerated}} */
        {{emit_verilog()}}
    """,
    "{{name}}.debug.v": r"""
        /* {{autogenerated}} */
        {{emit_debug_verilog()}}
    """,
    "{{name}}.ccf": r"""
        # {{autogenerated}}
	Pin_out "led_0__io" Loc = "IO_SB_B6" ;
	Pin_in "CLK0_0__io" Loc = "IO_SB_A8" ;
        #{% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
        #    {% set direction = attrs.get('dir', 'inout') %}
        #    {% if direction == 'i' -%}
        #        Pin_in "{{port_name}}" Loc = "{{pin_name}}" {% if attrs|length > 1 %}| {{ attrs|rejectattr('dir')|map('join', '=')|join(' | ') }} {% endif %};
        #    {% elif direction == 'o' -%}
        #        Pin_out "{{port_name}}" Loc = "{{pin_name}}" {% if attrs|length > 1 %}| {{ attrs|rejectattr('dir')|map('join', '=')|join(' | ') }} {% endif %};
        #    {% else -%}
        #        Pin_inout "{{port_name}}" Loc = "{{pin_name}}" {% if attrs|length > 1 %}| {{ attrs|rejectattr('dir')|map('join', '=')|join(' | ') }} {% endif %};
        #    {% endif %}
        #{% endfor %}
    """,
    "{{name}}.sdc": r"""
        # {{autogenerated}}
        {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
            {% if port_signal is not none -%}
                create_clock -period {{1000000000/frequency}} [get_ports {{port_signal.name|tcl_quote}}]
            {% endif %}
        {% endfor %}
    """,
    }

    command_templates = [
        r"""
        {{invoke_tool("yosys")}}
            -p 'read -sv {{name}}.v; synth_gatemate -top {{name}} -nomx8 -vlog {{name}}_synth.v'
        """,
        r"""
        {{invoke_tool("p_r")}}
            -i {{name}}_synth.v
            -o {{name}}
            -ccf {{name}}.ccf
        """,
        r"""
        {{invoke_tool("openFPGALoader")}}
            -b gatemate_evb_jtag --cable dirtyJtag --bitstream {{name}}_00.cfg.bit 
        """,
    ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.osc_freq = None
        self.osc_div = None

    @property
    def default_clk_constraint(self):
        if self.default_clk == "sys_clk0":
            return Clock(self.osc_freq / self.osc_div)
        return super().default_clk_constraint

    def add_clock_constraint(self, clock, frequency):
        super().add_clock_constraint(clock, frequency)
        clock.attrs["keep"] = "TRUE"

    def create_missing_domain(self, name):
        if name == "sync" and self.default_clk is not None:
            m = Module()
            if self.default_clk == "sys_clk0":
                if not hasattr(self, "osc_div"):
                    raise ValueError("OSC divider (osc_div) must be an integer between 2 and 512")
                if not isinstance(self.osc_div, int) or self.osc_div < 2 or self.osc_div > 512:
                    raise ValueError("OSC divider (osc_div) must be an integer between 2 and 512, not {!r}".format(self.osc_div))
                if not hasattr(self, "osc_freq"):
                    raise ValueError("OSC frequency (osc_freq) must be an integer between 2100000 and 80000000")
                if not isinstance(self.osc_freq, int) or self.osc_freq < 2100000 or self.osc_freq > 80000000:
                    raise ValueError("OSC frequency (osc_freq) must be an integer between 2100000 and 80000000, not {!r}".format(self.osc_freq))
                clk_i = Signal()
                sys_clk0 = Signal()
                m.submodules += Instance("qlal4s3b_cell_macro", o_Sys_Clk0=sys_clk0)
                m.submodules += Instance("gclkbuff", o_A=sys_clk0, o_Z=clk_i)
            else:
                clk_i = self.request(self.default_clk).i

            if self.default_rst is not None:
                rst_i = self.request(self.default_rst).i
            else:
                rst_i = Const(0)

            m.domains += ClockDomain("sync")
            m.d.comb += ClockSignal("sync").eq(clk_i)
            m.submodules.reset_sync = ResetSynchronizer(rst_i, domain="sync")
            return m

